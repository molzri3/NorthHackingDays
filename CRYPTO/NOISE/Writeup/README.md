# NOISE
## source
```py
from Crypto.Util.number import getPrime,bytes_to_long,GCD
import random
from SECRET import flag
m=bytes_to_long(flag)
p,q=getPrime(1024),getPrime(1024)
n=p*q
phi=(p-1)*(q-1)
e,f=0x1001,0x100f
d=pow(f,-1,phi)
print(f"D={d+random.getrandbits(8)}")
c=pow(m,e,n)
print(f"c={c}")
print(f"n={n}")
```
It's an internal common modulus attack. The code gives us some `D`, but with added random noise, which explains the challenge's name: **Noise**.
Let's do a little bit of math to understand:
- `f * d ≡ 1 (mod φ(n))` (RSA property)
- Rearranging: `f * d - 1 = k * φ(n)`, meaning `f * d - 1` is a multiple of `φ(n)`.
We can find the private key `d'` of `(e, n)` by taking the modular inverse of `e` under `(f * d - 1)`:
- `e * d' ≡ 1 (mod (k * φ(n)))`
However, there's a problem: we don't know `d`, because `d = D - random_noise`. 
The solution is to brute force the random noise.
## _
```py
from Crypto.Util.number import *
D=1659512355373418645140313284515838997981699731513965690812540239175288645045441512614179234142120260911636658220269405218524302520092621999844314768549544030654127500193914577937436318359462793138933589614762377498790765387632802077879233502428804005588157700257761855097250998919017898514176162487274386781198508237400353611464406193972964482117256226747476554782563744899993864304175436974698041084845847893679267899249989404432245426259402707880469555529604179813928822266453042385116501295217404138015353562442619085308553518462930118489574131224787804803488817818072641955305340871054682051568505455207418956278
c=15551861881651592419324953479034428140717805376306247719750747912911748226369930952588711774886548057529499850675742905233294668107466032497852816983660929947967706958664335762232679132207154728829957813693625093284502876882430192126201461183181597378253942499668380966968855069377373787904842425329143502990341588512700918378245187148573247647173636183038535602885416532079859604070477897822603680675563749446494936320722812734998974737194125303836011609538336040694032441189892434453855964474523358087949704442394448409485842983544392174679716264255668567668079161825656798264103183308827802954948548293303705265772
n=18898214107867379640365174273253778727708497496548235332217044108724685927373435064700528619274948455977114409815865719815383400720500745266925146851820430775676227571460340249032688932896818677546138467884454664536090959857502629756680135535969011819869574254181880848489747525086101331833180620457576188525229027744711592369051602059985587706689858737242125022155410339080447414129070246808368160147351511163493655165471532670846711289097090233706052690536984266690796303197054338969486921312985268704482848843270658704243402982220182608015852845667468677314795354301990261229002797300344412926123813746736017855111
e,f=0x1001,0x100f
for i in range(2**7,2**8):
    try:
        d=pow(e,-1,(D-i)*f-1)
        flag=long_to_bytes(pow(c,d,n))
        print(flag.decode('utf-8'))
        break
    except:pass                                      
```

